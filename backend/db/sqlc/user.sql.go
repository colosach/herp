// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const addPermissionToRole = `-- name: AddPermissionToRole :exec
INSERT INTO role_permissions (role_id, permission_id)
VALUES ($1, $2)
`

type AddPermissionToRoleParams struct {
	RoleID       int32 `json:"role_id"`
	PermissionID int32 `json:"permission_id"`
}

func (q *Queries) AddPermissionToRole(ctx context.Context, arg AddPermissionToRoleParams) error {
	_, err := q.db.ExecContext(ctx, addPermissionToRole, arg.RoleID, arg.PermissionID)
	return err
}

const cleanExpiredRefreshTokens = `-- name: CleanExpiredRefreshTokens :exec
DELETE FROM refresh_tokens
WHERE expires_at <= NOW() OR revoked = TRUE
`

func (q *Queries) CleanExpiredRefreshTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanExpiredRefreshTokens)
	return err
}

const clearAdminResetCode = `-- name: ClearAdminResetCode :exec
UPDATE admins
SET reset_code = NULL,
    reset_code_expires_at = NULL,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ClearAdminResetCode(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, clearAdminResetCode, id)
	return err
}

const createAdmin = `-- name: CreateAdmin :one
INSERT INTO admins (username, email, first_name, last_name, password_hash, role_id, is_active)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, first_name, last_name, username, email, password_hash, role_id, is_active, email_verified, verification_code, verification_expires_at, reset_code, reset_code_expires_at, created_at, updated_at
`

type CreateAdminParams struct {
	Username     string `json:"username"`
	Email        string `json:"email"`
	FirstName    string `json:"first_name"`
	LastName     string `json:"last_name"`
	PasswordHash string `json:"password_hash"`
	RoleID       int32  `json:"role_id"`
	IsActive     bool   `json:"is_active"`
}

func (q *Queries) CreateAdmin(ctx context.Context, arg CreateAdminParams) (Admin, error) {
	row := q.db.QueryRowContext(ctx, createAdmin,
		arg.Username,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.PasswordHash,
		arg.RoleID,
		arg.IsActive,
	)
	var i Admin
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.RoleID,
		&i.IsActive,
		&i.EmailVerified,
		&i.VerificationCode,
		&i.VerificationExpiresAt,
		&i.ResetCode,
		&i.ResetCodeExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPasswordResetToken = `-- name: CreatePasswordResetToken :one
INSERT INTO password_reset_tokens (user_id, token, expires_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, token, expires_at, used
`

type CreatePasswordResetTokenParams struct {
	UserID    int32     `json:"user_id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreatePasswordResetToken(ctx context.Context, arg CreatePasswordResetTokenParams) (PasswordResetToken, error) {
	row := q.db.QueryRowContext(ctx, createPasswordResetToken, arg.UserID, arg.Token, arg.ExpiresAt)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.Used,
	)
	return i, err
}

const createRefreshToken = `-- name: CreateRefreshToken :one
INSERT INTO refresh_tokens (user_id, token, expires_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, token, expires_at, revoked, created_at, updated_at
`

type CreateRefreshTokenParams struct {
	UserID    int32     `json:"user_id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) (RefreshToken, error) {
	row := q.db.QueryRowContext(ctx, createRefreshToken, arg.UserID, arg.Token, arg.ExpiresAt)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.Revoked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (name, description)
VALUES ($1, $2)
RETURNING id, name, description
`

type CreateRoleParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, createRole, arg.Name, arg.Description)
	var i Role
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, first_name, last_name, email, password_hash, gender, role_id, is_active)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, username, first_name, last_name, email, password_hash, gender, role_id, is_active, created_at, updated_at
`

type CreateUserParams struct {
	Username     string         `json:"username"`
	FirstName    string         `json:"first_name"`
	LastName     string         `json:"last_name"`
	Email        sql.NullString `json:"email"`
	PasswordHash string         `json:"password_hash"`
	Gender       sql.NullString `json:"gender"`
	RoleID       sql.NullInt32  `json:"role_id"`
	IsActive     sql.NullBool   `json:"is_active"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.PasswordHash,
		arg.Gender,
		arg.RoleID,
		arg.IsActive,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.Gender,
		&i.RoleID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAdmin = `-- name: DeleteAdmin :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteAdmin(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteAdmin, id)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles WHERE id = $1
`

func (q *Queries) DeleteRole(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteRole, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getAdminByEmail = `-- name: GetAdminByEmail :one
SELECT
    a.id,
    a.username,
    a.first_name,
    a.last_name,
    a.email,
    a.password_hash,
    a.is_active,
    a.email_verified,
    a.verification_code,
    a.verification_expires_at,
    a.reset_code,
    a.reset_code_expires_at,
    r.name as role_name
FROM admins a
JOIN roles r ON a.role_id = r.id
WHERE a.email = $1 LIMIT 1
`

type GetAdminByEmailRow struct {
	ID                    int32          `json:"id"`
	Username              string         `json:"username"`
	FirstName             string         `json:"first_name"`
	LastName              string         `json:"last_name"`
	Email                 string         `json:"email"`
	PasswordHash          string         `json:"password_hash"`
	IsActive              bool           `json:"is_active"`
	EmailVerified         bool           `json:"email_verified"`
	VerificationCode      sql.NullString `json:"verification_code"`
	VerificationExpiresAt sql.NullTime   `json:"verification_expires_at"`
	ResetCode             sql.NullString `json:"reset_code"`
	ResetCodeExpiresAt    sql.NullTime   `json:"reset_code_expires_at"`
	RoleName              string         `json:"role_name"`
}

func (q *Queries) GetAdminByEmail(ctx context.Context, email string) (GetAdminByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getAdminByEmail, email)
	var i GetAdminByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.IsActive,
		&i.EmailVerified,
		&i.VerificationCode,
		&i.VerificationExpiresAt,
		&i.ResetCode,
		&i.ResetCodeExpiresAt,
		&i.RoleName,
	)
	return i, err
}

const getAdminByUsername = `-- name: GetAdminByUsername :one
SELECT
    a.id,
    a.username,
    a.first_name,
    a.last_name,
    a.email,
    a.password_hash,
    a.is_active,
    a.email_verified,
    a.verification_code,
    a.verification_expires_at,
    a.reset_code,
    a.reset_code_expires_at,
    r.name as role_name
FROM admins a
JOIN roles r ON a.role_id = r.id
WHERE a.username = $1 LIMIT 1
`

type GetAdminByUsernameRow struct {
	ID                    int32          `json:"id"`
	Username              string         `json:"username"`
	FirstName             string         `json:"first_name"`
	LastName              string         `json:"last_name"`
	Email                 string         `json:"email"`
	PasswordHash          string         `json:"password_hash"`
	IsActive              bool           `json:"is_active"`
	EmailVerified         bool           `json:"email_verified"`
	VerificationCode      sql.NullString `json:"verification_code"`
	VerificationExpiresAt sql.NullTime   `json:"verification_expires_at"`
	ResetCode             sql.NullString `json:"reset_code"`
	ResetCodeExpiresAt    sql.NullTime   `json:"reset_code_expires_at"`
	RoleName              string         `json:"role_name"`
}

func (q *Queries) GetAdminByUsername(ctx context.Context, username string) (GetAdminByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getAdminByUsername, username)
	var i GetAdminByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.IsActive,
		&i.EmailVerified,
		&i.VerificationCode,
		&i.VerificationExpiresAt,
		&i.ResetCode,
		&i.ResetCodeExpiresAt,
		&i.RoleName,
	)
	return i, err
}

const getLoginHistory = `-- name: GetLoginHistory :many
SELECT id, username, email, login_time, ip_address, user_agent, success, error_reason FROM login_history
ORDER BY login_time DESC
LIMIT $1
`

func (q *Queries) GetLoginHistory(ctx context.Context, limit int32) ([]LoginHistory, error) {
	rows, err := q.db.QueryContext(ctx, getLoginHistory, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginHistory{}
	for rows.Next() {
		var i LoginHistory
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.LoginTime,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.ErrorReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPasswordResetToken = `-- name: GetPasswordResetToken :one
SELECT id, user_id, token, expires_at, used FROM password_reset_tokens
WHERE token = $1 AND expires_at > NOW() AND used = FALSE
LIMIT 1
`

func (q *Queries) GetPasswordResetToken(ctx context.Context, token string) (PasswordResetToken, error) {
	row := q.db.QueryRowContext(ctx, getPasswordResetToken, token)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.Used,
	)
	return i, err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT id, user_id, token, expires_at, revoked, created_at, updated_at FROM refresh_tokens
WHERE token = $1 AND expires_at > NOW() AND revoked = FALSE
LIMIT 1
`

func (q *Queries) GetRefreshToken(ctx context.Context, token string) (RefreshToken, error) {
	row := q.db.QueryRowContext(ctx, getRefreshToken, token)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.Revoked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoleByID = `-- name: GetRoleByID :one
SELECT id, name, description FROM roles WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRoleByID(ctx context.Context, id int32) (Role, error) {
	row := q.db.QueryRowContext(ctx, getRoleByID, id)
	var i Role
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getRolePermissions = `-- name: GetRolePermissions :many
SELECT p.id, p.code, p.description FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
WHERE rp.role_id = $1
`

func (q *Queries) GetRolePermissions(ctx context.Context, roleID int32) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getRolePermissions, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Code, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActivityLogs = `-- name: GetUserActivityLogs :many
SELECT id, user_id, action, details, entity_id, entity_type, ip_address, user_agent, created_at FROM user_activity_logs
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetUserActivityLogsParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) GetUserActivityLogs(ctx context.Context, arg GetUserActivityLogsParams) ([]UserActivityLog, error) {
	rows, err := q.db.QueryContext(ctx, getUserActivityLogs, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserActivityLog{}
	for rows.Next() {
		var i UserActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.Details,
			&i.EntityID,
			&i.EntityType,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
    u.id,
    u.username,
    u.first_name,
    u.last_name,
    u.email,
    u.password_hash,
    u.gender,
    u.is_active,
    r.name as role_name
FROM users u
JOIN roles r ON u.role_id = r.id
WHERE u.email = $1 LIMIT 1
`

type GetUserByEmailRow struct {
	ID           int32          `json:"id"`
	Username     string         `json:"username"`
	FirstName    string         `json:"first_name"`
	LastName     string         `json:"last_name"`
	Email        sql.NullString `json:"email"`
	PasswordHash string         `json:"password_hash"`
	Gender       sql.NullString `json:"gender"`
	IsActive     sql.NullBool   `json:"is_active"`
	RoleName     string         `json:"role_name"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email sql.NullString) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.Gender,
		&i.IsActive,
		&i.RoleName,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT u.id, u.username, u.first_name, u.last_name, u.email, u.password_hash, u.gender, u.role_id, u.is_active, u.created_at, u.updated_at, r.name as role_name FROM users u
JOIN roles r ON u.role_id = r.id
WHERE u.id = $1 LIMIT 1
`

type GetUserByIDRow struct {
	ID           int32          `json:"id"`
	Username     string         `json:"username"`
	FirstName    string         `json:"first_name"`
	LastName     string         `json:"last_name"`
	Email        sql.NullString `json:"email"`
	PasswordHash string         `json:"password_hash"`
	Gender       sql.NullString `json:"gender"`
	RoleID       sql.NullInt32  `json:"role_id"`
	IsActive     sql.NullBool   `json:"is_active"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	RoleName     string         `json:"role_name"`
}

func (q *Queries) GetUserByID(ctx context.Context, id int32) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.Gender,
		&i.RoleID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RoleName,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT
    u.id,
    u.username,
    u.first_name,
    u.last_name,
    u.email,
    u.password_hash,
    u.gender,
    u.is_active,
    r.name as role_name
FROM users u
JOIN roles r ON u.role_id = r.id
WHERE u.username = $1 LIMIT 1
`

type GetUserByUsernameRow struct {
	ID           int32          `json:"id"`
	Username     string         `json:"username"`
	FirstName    string         `json:"first_name"`
	LastName     string         `json:"last_name"`
	Email        sql.NullString `json:"email"`
	PasswordHash string         `json:"password_hash"`
	Gender       sql.NullString `json:"gender"`
	IsActive     sql.NullBool   `json:"is_active"`
	RoleName     string         `json:"role_name"`
}

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (GetUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.Gender,
		&i.IsActive,
		&i.RoleName,
	)
	return i, err
}

const getUserPermissions = `-- name: GetUserPermissions :many
SELECT p.code
FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
JOIN roles r ON rp.role_id = r.id
JOIN users u ON u.role_id = r.id
WHERE u.id = $1
`

func (q *Queries) GetUserPermissions(ctx context.Context, id int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUserPermissions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var code string
		if err := rows.Scan(&code); err != nil {
			return nil, err
		}
		items = append(items, code)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
SELECT id, name, description FROM roles ORDER BY name
`

func (q *Queries) ListRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, listRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT u.id, u.username, u.first_name, u.last_name, u.email, u.password_hash, u.gender, u.role_id, u.is_active, u.created_at, u.updated_at, r.name as role_name FROM users u
JOIN roles r ON u.role_id = r.id
ORDER BY u.created_at DESC
`

type ListUsersRow struct {
	ID           int32          `json:"id"`
	Username     string         `json:"username"`
	FirstName    string         `json:"first_name"`
	LastName     string         `json:"last_name"`
	Email        sql.NullString `json:"email"`
	PasswordHash string         `json:"password_hash"`
	Gender       sql.NullString `json:"gender"`
	RoleID       sql.NullInt32  `json:"role_id"`
	IsActive     sql.NullBool   `json:"is_active"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	RoleName     string         `json:"role_name"`
}

func (q *Queries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.PasswordHash,
			&i.Gender,
			&i.RoleID,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logLoginHistory = `-- name: LogLoginHistory :exec
INSERT INTO login_history (username, email, ip_address, user_agent, success, error_reason)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, username, email, login_time, ip_address, user_agent, success, error_reason
`

type LogLoginHistoryParams struct {
	Username    string         `json:"username"`
	Email       sql.NullString `json:"email"`
	IpAddress   sql.NullString `json:"ip_address"`
	UserAgent   sql.NullString `json:"user_agent"`
	Success     bool           `json:"success"`
	ErrorReason sql.NullString `json:"error_reason"`
}

func (q *Queries) LogLoginHistory(ctx context.Context, arg LogLoginHistoryParams) error {
	_, err := q.db.ExecContext(ctx, logLoginHistory,
		arg.Username,
		arg.Email,
		arg.IpAddress,
		arg.UserAgent,
		arg.Success,
		arg.ErrorReason,
	)
	return err
}

const logUserActivity = `-- name: LogUserActivity :one
INSERT INTO user_activity_logs (user_id, action, details, entity_id, entity_type, ip_address, user_agent)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, action, details, entity_id, entity_type, ip_address, user_agent, created_at
`

type LogUserActivityParams struct {
	UserID     int32           `json:"user_id"`
	Action     string          `json:"action"`
	Details    json.RawMessage `json:"details"`
	EntityID   int32           `json:"entity_id"`
	EntityType string          `json:"entity_type"`
	IpAddress  sql.NullString  `json:"ip_address"`
	UserAgent  sql.NullString  `json:"user_agent"`
}

func (q *Queries) LogUserActivity(ctx context.Context, arg LogUserActivityParams) (UserActivityLog, error) {
	row := q.db.QueryRowContext(ctx, logUserActivity,
		arg.UserID,
		arg.Action,
		arg.Details,
		arg.EntityID,
		arg.EntityType,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i UserActivityLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.Details,
		&i.EntityID,
		&i.EntityType,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const markAdminEmailVerified = `-- name: MarkAdminEmailVerified :exec
UPDATE admins
SET email_verified = $2,
    verification_code = NULL,
    verification_expires_at = NULL,
    updated_at = NOW()
WHERE id = $1
`

type MarkAdminEmailVerifiedParams struct {
	ID            int32 `json:"id"`
	EmailVerified bool  `json:"email_verified"`
}

func (q *Queries) MarkAdminEmailVerified(ctx context.Context, arg MarkAdminEmailVerifiedParams) error {
	_, err := q.db.ExecContext(ctx, markAdminEmailVerified, arg.ID, arg.EmailVerified)
	return err
}

const markTokenAsUsed = `-- name: MarkTokenAsUsed :exec
UPDATE password_reset_tokens
SET used = TRUE
WHERE id = $1
`

func (q *Queries) MarkTokenAsUsed(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markTokenAsUsed, id)
	return err
}

const removePermissionFromRole = `-- name: RemovePermissionFromRole :exec
DELETE FROM role_permissions
WHERE role_id = $1 AND permission_id = $2
`

type RemovePermissionFromRoleParams struct {
	RoleID       int32 `json:"role_id"`
	PermissionID int32 `json:"permission_id"`
}

func (q *Queries) RemovePermissionFromRole(ctx context.Context, arg RemovePermissionFromRoleParams) error {
	_, err := q.db.ExecContext(ctx, removePermissionFromRole, arg.RoleID, arg.PermissionID)
	return err
}

const revokeAllUserRefreshTokens = `-- name: RevokeAllUserRefreshTokens :exec
UPDATE refresh_tokens
SET revoked = TRUE, updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1
`

func (q *Queries) RevokeAllUserRefreshTokens(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, revokeAllUserRefreshTokens, userID)
	return err
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :exec
UPDATE refresh_tokens
SET revoked = TRUE, updated_at = CURRENT_TIMESTAMP
WHERE token = $1
`

func (q *Queries) RevokeRefreshToken(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, revokeRefreshToken, token)
	return err
}

const setAdminEmailVerification = `-- name: SetAdminEmailVerification :exec
UPDATE admins
SET verification_code = $2,
    verification_expires_at = $3,
    updated_at = NOW()
WHERE id = $1
`

type SetAdminEmailVerificationParams struct {
	ID                    int32          `json:"id"`
	VerificationCode      sql.NullString `json:"verification_code"`
	VerificationExpiresAt sql.NullTime   `json:"verification_expires_at"`
}

func (q *Queries) SetAdminEmailVerification(ctx context.Context, arg SetAdminEmailVerificationParams) error {
	_, err := q.db.ExecContext(ctx, setAdminEmailVerification, arg.ID, arg.VerificationCode, arg.VerificationExpiresAt)
	return err
}

const setAdminResetCode = `-- name: SetAdminResetCode :exec
UPDATE admins
SET reset_code = $2,
    reset_code_expires_at = $3,
    updated_at = NOW()
WHERE id = $1
`

type SetAdminResetCodeParams struct {
	ID                 int32          `json:"id"`
	ResetCode          sql.NullString `json:"reset_code"`
	ResetCodeExpiresAt sql.NullTime   `json:"reset_code_expires_at"`
}

func (q *Queries) SetAdminResetCode(ctx context.Context, arg SetAdminResetCodeParams) error {
	_, err := q.db.ExecContext(ctx, setAdminResetCode, arg.ID, arg.ResetCode, arg.ResetCodeExpiresAt)
	return err
}

const updateAdminPassword = `-- name: UpdateAdminPassword :exec
UPDATE admins
SET password_hash = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateAdminPasswordParams struct {
	ID           int32  `json:"id"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) UpdateAdminPassword(ctx context.Context, arg UpdateAdminPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminPassword, arg.ID, arg.PasswordHash)
	return err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles
SET
    name = COALESCE($2, name),
    description = COALESCE($3, description)
WHERE id = $1
RETURNING id, name, description
`

type UpdateRoleParams struct {
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, updateRole, arg.ID, arg.Name, arg.Description)
	var i Role
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET username   = COALESCE($1, username),
    first_name = COALESCE($2, first_name),
    last_name  = COALESCE($3, last_name),
    email      = COALESCE($4, email),
    gender     = COALESCE($5, gender),
    role_id    = COALESCE($6, role_id),
    is_active  = COALESCE($7, is_active)
WHERE id = $8
RETURNING id, username, first_name, last_name, email, password_hash, gender, role_id, is_active, created_at, updated_at
`

type UpdateUserParams struct {
	Username  sql.NullString `json:"username"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	Email     sql.NullString `json:"email"`
	Gender    sql.NullString `json:"gender"`
	RoleID    sql.NullInt32  `json:"role_id"`
	IsActive  sql.NullBool   `json:"is_active"`
	ID        int32          `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Gender,
		arg.RoleID,
		arg.IsActive,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.Gender,
		&i.RoleID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID           int32  `json:"id"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUserStatus = `-- name: UpdateUserStatus :exec
UPDATE users
SET is_active = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateUserStatusParams struct {
	ID       int32        `json:"id"`
	IsActive sql.NullBool `json:"is_active"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateUserStatus, arg.ID, arg.IsActive)
	return err
}
