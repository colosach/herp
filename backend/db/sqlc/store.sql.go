// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: store.sql

package db

import (
	"context"
	"database/sql"
)

const createStore = `-- name: CreateStore :one
INSERT INTO store (
    name, description, branch_id, address, phone, email, 
    is_active, store_code, store_type, assigned_user, manager_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id, name, description, branch_id, address, phone, email, is_active, store_type, store_code, created_at, updated_at, assigned_user, manager_id
`

type CreateStoreParams struct {
	Name         string         `json:"name"`
	Description  sql.NullString `json:"description"`
	BranchID     int32          `json:"branch_id"`
	Address      string         `json:"address"`
	Phone        string         `json:"phone"`
	Email        string         `json:"email"`
	IsActive     sql.NullBool   `json:"is_active"`
	StoreCode    string         `json:"store_code"`
	StoreType    string         `json:"store_type"`
	AssignedUser sql.NullInt32  `json:"assigned_user"`
	ManagerID    sql.NullInt32  `json:"manager_id"`
}

func (q *Queries) CreateStore(ctx context.Context, arg CreateStoreParams) (Store, error) {
	row := q.db.QueryRowContext(ctx, createStore,
		arg.Name,
		arg.Description,
		arg.BranchID,
		arg.Address,
		arg.Phone,
		arg.Email,
		arg.IsActive,
		arg.StoreCode,
		arg.StoreType,
		arg.AssignedUser,
		arg.ManagerID,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BranchID,
		&i.Address,
		&i.Phone,
		&i.Email,
		&i.IsActive,
		&i.StoreType,
		&i.StoreCode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AssignedUser,
		&i.ManagerID,
	)
	return i, err
}

const deactivateStore = `-- name: DeactivateStore :one
UPDATE store
SET is_active = FALSE,
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, branch_id, address, phone, email, is_active, store_type, store_code, created_at, updated_at, assigned_user, manager_id
`

func (q *Queries) DeactivateStore(ctx context.Context, id int32) (Store, error) {
	row := q.db.QueryRowContext(ctx, deactivateStore, id)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BranchID,
		&i.Address,
		&i.Phone,
		&i.Email,
		&i.IsActive,
		&i.StoreType,
		&i.StoreCode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AssignedUser,
		&i.ManagerID,
	)
	return i, err
}

const deleteStore = `-- name: DeleteStore :exec
DELETE FROM store WHERE id = $1
`

func (q *Queries) DeleteStore(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteStore, id)
	return err
}

const getCentralStoreByBranch = `-- name: GetCentralStoreByBranch :one
SELECT id, name, description, branch_id, address, phone, email, is_active, store_type, store_code, created_at, updated_at, assigned_user, manager_id FROM store WHERE branch_id = $1 AND store_type = 'central' LIMIT 1
`

func (q *Queries) GetCentralStoreByBranch(ctx context.Context, branchID int32) (Store, error) {
	row := q.db.QueryRowContext(ctx, getCentralStoreByBranch, branchID)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BranchID,
		&i.Address,
		&i.Phone,
		&i.Email,
		&i.IsActive,
		&i.StoreType,
		&i.StoreCode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AssignedUser,
		&i.ManagerID,
	)
	return i, err
}

const getStoreByID = `-- name: GetStoreByID :one
SELECT id, name, description, branch_id, address, phone, email, is_active, store_type, store_code, created_at, updated_at, assigned_user, manager_id FROM store WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStoreByID(ctx context.Context, id int32) (Store, error) {
	row := q.db.QueryRowContext(ctx, getStoreByID, id)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BranchID,
		&i.Address,
		&i.Phone,
		&i.Email,
		&i.IsActive,
		&i.StoreType,
		&i.StoreCode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AssignedUser,
		&i.ManagerID,
	)
	return i, err
}

const getStoresByBranch = `-- name: GetStoresByBranch :many
SELECT id, name, description, branch_id, address, phone, email, is_active, store_type, store_code, created_at, updated_at, assigned_user, manager_id FROM store WHERE branch_id = $1 ORDER BY name
`

func (q *Queries) GetStoresByBranch(ctx context.Context, branchID int32) ([]Store, error) {
	rows, err := q.db.QueryContext(ctx, getStoresByBranch, branchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Store{}
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BranchID,
			&i.Address,
			&i.Phone,
			&i.Email,
			&i.IsActive,
			&i.StoreType,
			&i.StoreCode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssignedUser,
			&i.ManagerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStores = `-- name: ListStores :many
SELECT id, name, description, branch_id, address, phone, email, is_active, store_type, store_code, created_at, updated_at, assigned_user, manager_id FROM store ORDER BY created_at DESC
`

func (q *Queries) ListStores(ctx context.Context) ([]Store, error) {
	rows, err := q.db.QueryContext(ctx, listStores)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Store{}
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BranchID,
			&i.Address,
			&i.Phone,
			&i.Email,
			&i.IsActive,
			&i.StoreType,
			&i.StoreCode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssignedUser,
			&i.ManagerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchStoresByName = `-- name: SearchStoresByName :many
SELECT id, name, description, branch_id, address, phone, email, is_active, store_type, store_code, created_at, updated_at, assigned_user, manager_id FROM store
WHERE name ILIKE '%' || $1 || '%'
ORDER BY name
`

func (q *Queries) SearchStoresByName(ctx context.Context, dollar_1 sql.NullString) ([]Store, error) {
	rows, err := q.db.QueryContext(ctx, searchStoresByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Store{}
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BranchID,
			&i.Address,
			&i.Phone,
			&i.Email,
			&i.IsActive,
			&i.StoreType,
			&i.StoreCode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssignedUser,
			&i.ManagerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStore = `-- name: UpdateStore :one
UPDATE store
SET name = $2,
    description = $3,
    address = $4,
    phone = $5,
    email = $6,
    is_active = $7,
    store_code = $8,
    store_type = $9,
    assigned_user = $10,
    manager_id = $11,
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, branch_id, address, phone, email, is_active, store_type, store_code, created_at, updated_at, assigned_user, manager_id
`

type UpdateStoreParams struct {
	ID           int32          `json:"id"`
	Name         string         `json:"name"`
	Description  sql.NullString `json:"description"`
	Address      string         `json:"address"`
	Phone        string         `json:"phone"`
	Email        string         `json:"email"`
	IsActive     sql.NullBool   `json:"is_active"`
	StoreCode    string         `json:"store_code"`
	StoreType    string         `json:"store_type"`
	AssignedUser sql.NullInt32  `json:"assigned_user"`
	ManagerID    sql.NullInt32  `json:"manager_id"`
}

func (q *Queries) UpdateStore(ctx context.Context, arg UpdateStoreParams) (Store, error) {
	row := q.db.QueryRowContext(ctx, updateStore,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Address,
		arg.Phone,
		arg.Email,
		arg.IsActive,
		arg.StoreCode,
		arg.StoreType,
		arg.AssignedUser,
		arg.ManagerID,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BranchID,
		&i.Address,
		&i.Phone,
		&i.Email,
		&i.IsActive,
		&i.StoreType,
		&i.StoreCode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AssignedUser,
		&i.ManagerID,
	)
	return i, err
}
