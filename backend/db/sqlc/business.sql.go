// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: business.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const createBranch = `-- name: CreateBranch :one
INSERT INTO branch (
    business_id, name, address_one, addres_two, country, phone, email, website, city, state, zip_code
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, business_id, name, address_one, addres_two, country, phone, email, website, city, state, zip_code, created_at, updated_at
`

type CreateBranchParams struct {
	BusinessID int32          `json:"business_id"`
	Name       string         `json:"name"`
	AddressOne sql.NullString `json:"address_one"`
	AddresTwo  sql.NullString `json:"addres_two"`
	Country    sql.NullString `json:"country"`
	Phone      sql.NullString `json:"phone"`
	Email      sql.NullString `json:"email"`
	Website    sql.NullString `json:"website"`
	City       sql.NullString `json:"city"`
	State      sql.NullString `json:"state"`
	ZipCode    sql.NullString `json:"zip_code"`
}

func (q *Queries) CreateBranch(ctx context.Context, arg CreateBranchParams) (Branch, error) {
	row := q.db.QueryRowContext(ctx, createBranch,
		arg.BusinessID,
		arg.Name,
		arg.AddressOne,
		arg.AddresTwo,
		arg.Country,
		arg.Phone,
		arg.Email,
		arg.Website,
		arg.City,
		arg.State,
		arg.ZipCode,
	)
	var i Branch
	err := row.Scan(
		&i.ID,
		&i.BusinessID,
		&i.Name,
		&i.AddressOne,
		&i.AddresTwo,
		&i.Country,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createBusiness = `-- name: CreateBusiness :one
INSERT INTO business (
    owner_id, name, motto, email, website, tax_id, tax_rate,
    country, logo_url, rounding, currency, timezone, language,
    low_stock_threshold, allow_overselling, payment_type,
    font, primary_color
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13,
    $14, $15, $16, $17, $18
) RETURNING id, owner_id, name, motto, email, website, tax_id, tax_rate, country, logo_url, rounding, currency, timezone, language, low_stock_threshold, allow_overselling, payment_type, font, primary_color, created_at, updated_at
`

type CreateBusinessParams struct {
	OwnerID           int32          `json:"owner_id"`
	Name              string         `json:"name"`
	Motto             sql.NullString `json:"motto"`
	Email             sql.NullString `json:"email"`
	Website           sql.NullString `json:"website"`
	TaxID             sql.NullString `json:"tax_id"`
	TaxRate           sql.NullString `json:"tax_rate"`
	Country           string         `json:"country"`
	LogoUrl           sql.NullString `json:"logo_url"`
	Rounding          sql.NullString `json:"rounding"`
	Currency          sql.NullString `json:"currency"`
	Timezone          sql.NullString `json:"timezone"`
	Language          sql.NullString `json:"language"`
	LowStockThreshold sql.NullInt32  `json:"low_stock_threshold"`
	AllowOverselling  sql.NullBool   `json:"allow_overselling"`
	PaymentType       []PaymentType  `json:"payment_type"`
	Font              sql.NullString `json:"font"`
	PrimaryColor      sql.NullString `json:"primary_color"`
}

func (q *Queries) CreateBusiness(ctx context.Context, arg CreateBusinessParams) (Business, error) {
	row := q.db.QueryRowContext(ctx, createBusiness,
		arg.OwnerID,
		arg.Name,
		arg.Motto,
		arg.Email,
		arg.Website,
		arg.TaxID,
		arg.TaxRate,
		arg.Country,
		arg.LogoUrl,
		arg.Rounding,
		arg.Currency,
		arg.Timezone,
		arg.Language,
		arg.LowStockThreshold,
		arg.AllowOverselling,
		pq.Array(arg.PaymentType),
		arg.Font,
		arg.PrimaryColor,
	)
	var i Business
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Motto,
		&i.Email,
		&i.Website,
		&i.TaxID,
		&i.TaxRate,
		&i.Country,
		&i.LogoUrl,
		&i.Rounding,
		&i.Currency,
		&i.Timezone,
		&i.Language,
		&i.LowStockThreshold,
		&i.AllowOverselling,
		pq.Array(&i.PaymentType),
		&i.Font,
		&i.PrimaryColor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBranch = `-- name: DeleteBranch :one
DELETE FROM branch WHERE id = $1
RETURNING id, business_id, name, address_one, addres_two, country, phone, email, website, city, state, zip_code, created_at, updated_at
`

func (q *Queries) DeleteBranch(ctx context.Context, id int32) (Branch, error) {
	row := q.db.QueryRowContext(ctx, deleteBranch, id)
	var i Branch
	err := row.Scan(
		&i.ID,
		&i.BusinessID,
		&i.Name,
		&i.AddressOne,
		&i.AddresTwo,
		&i.Country,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBusiness = `-- name: DeleteBusiness :one
DELETE FROM business
WHERE id = $1 AND owner_id = $2
RETURNING id, owner_id, name, motto, email, website, tax_id, tax_rate, country, logo_url, rounding, currency, timezone, language, low_stock_threshold, allow_overselling, payment_type, font, primary_color, created_at, updated_at
`

type DeleteBusinessParams struct {
	ID      int32 `json:"id"`
	OwnerID int32 `json:"owner_id"`
}

func (q *Queries) DeleteBusiness(ctx context.Context, arg DeleteBusinessParams) (Business, error) {
	row := q.db.QueryRowContext(ctx, deleteBusiness, arg.ID, arg.OwnerID)
	var i Business
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Motto,
		&i.Email,
		&i.Website,
		&i.TaxID,
		&i.TaxRate,
		&i.Country,
		&i.LogoUrl,
		&i.Rounding,
		&i.Currency,
		&i.Timezone,
		&i.Language,
		&i.LowStockThreshold,
		&i.AllowOverselling,
		pq.Array(&i.PaymentType),
		&i.Font,
		&i.PrimaryColor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBranch = `-- name: GetBranch :one
SELECT id, business_id, name, address_one, addres_two, country, phone, email, website, city, state, zip_code, created_at, updated_at FROM branch WHERE id = $1
`

func (q *Queries) GetBranch(ctx context.Context, id int32) (Branch, error) {
	row := q.db.QueryRowContext(ctx, getBranch, id)
	var i Branch
	err := row.Scan(
		&i.ID,
		&i.BusinessID,
		&i.Name,
		&i.AddressOne,
		&i.AddresTwo,
		&i.Country,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBusiness = `-- name: GetBusiness :one
SELECT id, owner_id, name, motto, email, website, tax_id, tax_rate, country, logo_url, rounding, currency, timezone, language, low_stock_threshold, allow_overselling, payment_type, font, primary_color, created_at, updated_at
FROM business
WHERE id = $1 AND owner_id = $2
`

type GetBusinessParams struct {
	ID      int32 `json:"id"`
	OwnerID int32 `json:"owner_id"`
}

func (q *Queries) GetBusiness(ctx context.Context, arg GetBusinessParams) (Business, error) {
	row := q.db.QueryRowContext(ctx, getBusiness, arg.ID, arg.OwnerID)
	var i Business
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Motto,
		&i.Email,
		&i.Website,
		&i.TaxID,
		&i.TaxRate,
		&i.Country,
		&i.LogoUrl,
		&i.Rounding,
		&i.Currency,
		&i.Timezone,
		&i.Language,
		&i.LowStockThreshold,
		&i.AllowOverselling,
		pq.Array(&i.PaymentType),
		&i.Font,
		&i.PrimaryColor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBranches = `-- name: ListBranches :many
SELECT id, business_id, name, address_one, addres_two, country, phone, email, website, city, state, zip_code, created_at, updated_at FROM branch ORDER BY created_at DESC
`

func (q *Queries) ListBranches(ctx context.Context) ([]Branch, error) {
	rows, err := q.db.QueryContext(ctx, listBranches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Branch{}
	for rows.Next() {
		var i Branch
		if err := rows.Scan(
			&i.ID,
			&i.BusinessID,
			&i.Name,
			&i.AddressOne,
			&i.AddresTwo,
			&i.Country,
			&i.Phone,
			&i.Email,
			&i.Website,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBusinesses = `-- name: ListBusinesses :many
SELECT id, owner_id, name, motto, email, website, tax_id, tax_rate, country, logo_url, rounding, currency, timezone, language, low_stock_threshold, allow_overselling, payment_type, font, primary_color, created_at, updated_at
FROM business
WHERE owner_id = $1
ORDER BY created_at
`

func (q *Queries) ListBusinesses(ctx context.Context, ownerID int32) ([]Business, error) {
	rows, err := q.db.QueryContext(ctx, listBusinesses, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Business{}
	for rows.Next() {
		var i Business
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Motto,
			&i.Email,
			&i.Website,
			&i.TaxID,
			&i.TaxRate,
			&i.Country,
			&i.LogoUrl,
			&i.Rounding,
			&i.Currency,
			&i.Timezone,
			&i.Language,
			&i.LowStockThreshold,
			&i.AllowOverselling,
			pq.Array(&i.PaymentType),
			&i.Font,
			&i.PrimaryColor,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBranch = `-- name: UpdateBranch :one
UPDATE branch SET
    name = $2,
    address_one = $3,
    addres_two = $4,
    country = $5,
    phone = $6,
    email = $7,
    website = $8,
    city = $9,
    state = $10,
    zip_code = $11,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, business_id, name, address_one, addres_two, country, phone, email, website, city, state, zip_code, created_at, updated_at
`

type UpdateBranchParams struct {
	ID         int32          `json:"id"`
	Name       string         `json:"name"`
	AddressOne sql.NullString `json:"address_one"`
	AddresTwo  sql.NullString `json:"addres_two"`
	Country    sql.NullString `json:"country"`
	Phone      sql.NullString `json:"phone"`
	Email      sql.NullString `json:"email"`
	Website    sql.NullString `json:"website"`
	City       sql.NullString `json:"city"`
	State      sql.NullString `json:"state"`
	ZipCode    sql.NullString `json:"zip_code"`
}

func (q *Queries) UpdateBranch(ctx context.Context, arg UpdateBranchParams) (Branch, error) {
	row := q.db.QueryRowContext(ctx, updateBranch,
		arg.ID,
		arg.Name,
		arg.AddressOne,
		arg.AddresTwo,
		arg.Country,
		arg.Phone,
		arg.Email,
		arg.Website,
		arg.City,
		arg.State,
		arg.ZipCode,
	)
	var i Branch
	err := row.Scan(
		&i.ID,
		&i.BusinessID,
		&i.Name,
		&i.AddressOne,
		&i.AddresTwo,
		&i.Country,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBusiness = `-- name: UpdateBusiness :one
UPDATE business SET
    name = COALESCE($1, name),
    motto = COALESCE($2, motto),
    email = COALESCE($3, email),
    website = COALESCE($4, website),
    tax_id = COALESCE($5, tax_id),
    tax_rate = COALESCE($6, tax_rate),
    logo_url = COALESCE($7, logo_url),
    rounding = COALESCE($8, rounding),
    currency = COALESCE($9, currency),
    timezone = COALESCE($10, timezone),
    language = COALESCE($11, language),
    low_stock_threshold = COALESCE($12, low_stock_threshold),
    allow_overselling = COALESCE($13, allow_overselling),
    payment_type = COALESCE($14, payment_type),
    font = COALESCE($15, font),
    primary_color = COALESCE($16, primary_color),
    country = COALESCE($17, country),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $18 AND owner_id = $19
RETURNING id, owner_id, name, motto, email, website, tax_id, tax_rate, country, logo_url, rounding, currency, timezone, language, low_stock_threshold, allow_overselling, payment_type, font, primary_color, created_at, updated_at
`

type UpdateBusinessParams struct {
	Name              sql.NullString `json:"name"`
	Motto             sql.NullString `json:"motto"`
	Email             sql.NullString `json:"email"`
	Website           sql.NullString `json:"website"`
	TaxID             sql.NullString `json:"tax_id"`
	TaxRate           sql.NullString `json:"tax_rate"`
	LogoUrl           sql.NullString `json:"logo_url"`
	Rounding          sql.NullString `json:"rounding"`
	Currency          sql.NullString `json:"currency"`
	Timezone          sql.NullString `json:"timezone"`
	Language          sql.NullString `json:"language"`
	LowStockThreshold sql.NullInt32  `json:"low_stock_threshold"`
	AllowOverselling  sql.NullBool   `json:"allow_overselling"`
	PaymentType       []PaymentType  `json:"payment_type"`
	Font              sql.NullString `json:"font"`
	PrimaryColor      sql.NullString `json:"primary_color"`
	Country           sql.NullString `json:"country"`
	ID                int32          `json:"id"`
	OwnerID           int32          `json:"owner_id"`
}

func (q *Queries) UpdateBusiness(ctx context.Context, arg UpdateBusinessParams) (Business, error) {
	row := q.db.QueryRowContext(ctx, updateBusiness,
		arg.Name,
		arg.Motto,
		arg.Email,
		arg.Website,
		arg.TaxID,
		arg.TaxRate,
		arg.LogoUrl,
		arg.Rounding,
		arg.Currency,
		arg.Timezone,
		arg.Language,
		arg.LowStockThreshold,
		arg.AllowOverselling,
		pq.Array(arg.PaymentType),
		arg.Font,
		arg.PrimaryColor,
		arg.Country,
		arg.ID,
		arg.OwnerID,
	)
	var i Business
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Motto,
		&i.Email,
		&i.Website,
		&i.TaxID,
		&i.TaxRate,
		&i.Country,
		&i.LogoUrl,
		&i.Rounding,
		&i.Currency,
		&i.Timezone,
		&i.Language,
		&i.LowStockThreshold,
		&i.AllowOverselling,
		pq.Array(&i.PaymentType),
		&i.Font,
		&i.PrimaryColor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
