// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addPermissionToRole = `-- name: AddPermissionToRole :exec
INSERT INTO role_permissions (role_id, permission_id)
VALUES ($1, $2)
`

type AddPermissionToRoleParams struct {
	RoleID       int32 `json:"role_id"`
	PermissionID int32 `json:"permission_id"`
}

func (q *Queries) AddPermissionToRole(ctx context.Context, arg AddPermissionToRoleParams) error {
	_, err := q.db.ExecContext(ctx, addPermissionToRole, arg.RoleID, arg.PermissionID)
	return err
}

const createPasswordResetToken = `-- name: CreatePasswordResetToken :one
INSERT INTO password_reset_tokens (user_id, token, expires_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, token, expires_at, used
`

type CreatePasswordResetTokenParams struct {
	UserID    int32     `json:"user_id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreatePasswordResetToken(ctx context.Context, arg CreatePasswordResetTokenParams) (PasswordResetToken, error) {
	row := q.db.QueryRowContext(ctx, createPasswordResetToken, arg.UserID, arg.Token, arg.ExpiresAt)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.Used,
	)
	return i, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (name, description)
VALUES ($1, $2)
RETURNING id, name, description
`

type CreateRoleParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, createRole, arg.Name, arg.Description)
	var i Role
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (first_name, last_name, email, password_hash, role_id, is_active, nin, gender, date_of_birth)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, first_name, last_name, email, password_hash, nin, gender, date_of_birth, role_id, is_active, created_at, updated_at
`

type CreateUserParams struct {
	FirstName    string    `json:"first_name"`
	LastName     string    `json:"last_name"`
	Email        string    `json:"email"`
	PasswordHash string    `json:"password_hash"`
	RoleID       int32     `json:"role_id"`
	IsActive     bool      `json:"is_active"`
	Nin          string    `json:"nin"`
	Gender       string    `json:"gender"`
	DateOfBirth  time.Time `json:"date_of_birth"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.PasswordHash,
		arg.RoleID,
		arg.IsActive,
		arg.Nin,
		arg.Gender,
		arg.DateOfBirth,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.Nin,
		&i.Gender,
		&i.DateOfBirth,
		&i.RoleID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles WHERE id = $1
`

func (q *Queries) DeleteRole(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteRole, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getPasswordResetToken = `-- name: GetPasswordResetToken :one
SELECT id, user_id, token, expires_at, used FROM password_reset_tokens
WHERE token = $1 AND expires_at > NOW() AND used = FALSE
LIMIT 1
`

func (q *Queries) GetPasswordResetToken(ctx context.Context, token string) (PasswordResetToken, error) {
	row := q.db.QueryRowContext(ctx, getPasswordResetToken, token)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.Used,
	)
	return i, err
}

const getRoleByID = `-- name: GetRoleByID :one
SELECT id, name, description FROM roles WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRoleByID(ctx context.Context, id int32) (Role, error) {
	row := q.db.QueryRowContext(ctx, getRoleByID, id)
	var i Role
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getRolePermissions = `-- name: GetRolePermissions :many
SELECT p.id, p.code, p.description FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
WHERE rp.role_id = $1
`

func (q *Queries) GetRolePermissions(ctx context.Context, roleID int32) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getRolePermissions, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Code, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActivityLogs = `-- name: GetUserActivityLogs :many
SELECT id, user_id, action, description, ip_address, user_agent, created_at FROM user_activity_logs
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetUserActivityLogsParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) GetUserActivityLogs(ctx context.Context, arg GetUserActivityLogsParams) ([]UserActivityLog, error) {
	rows, err := q.db.QueryContext(ctx, getUserActivityLogs, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserActivityLog{}
	for rows.Next() {
		var i UserActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.Description,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
    u.id,
    u.first_name,
    u.last_name,
    u.email,
    u.password_hash,
    u.is_active,
    r.name as role_name
FROM users u
JOIN roles r ON u.role_id = r.id
WHERE u.email = $1 LIMIT 1
`

type GetUserByEmailRow struct {
	ID           int32  `json:"id"`
	FirstName    string `json:"first_name"`
	LastName     string `json:"last_name"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
	IsActive     bool   `json:"is_active"`
	RoleName     string `json:"role_name"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.IsActive,
		&i.RoleName,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT u.id, u.first_name, u.last_name, u.email, u.password_hash, u.nin, u.gender, u.date_of_birth, u.role_id, u.is_active, u.created_at, u.updated_at, r.name as role_name FROM users u
JOIN roles r ON u.role_id = r.id
WHERE u.id = $1 LIMIT 1
`

type GetUserByIDRow struct {
	ID           int32        `json:"id"`
	FirstName    string       `json:"first_name"`
	LastName     string       `json:"last_name"`
	Email        string       `json:"email"`
	PasswordHash string       `json:"password_hash"`
	Nin          string       `json:"nin"`
	Gender       string       `json:"gender"`
	DateOfBirth  time.Time    `json:"date_of_birth"`
	RoleID       int32        `json:"role_id"`
	IsActive     bool         `json:"is_active"`
	CreatedAt    sql.NullTime `json:"created_at"`
	UpdatedAt    sql.NullTime `json:"updated_at"`
	RoleName     string       `json:"role_name"`
}

func (q *Queries) GetUserByID(ctx context.Context, id int32) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.Nin,
		&i.Gender,
		&i.DateOfBirth,
		&i.RoleID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RoleName,
	)
	return i, err
}

const getUserLoginHistory = `-- name: GetUserLoginHistory :many
SELECT id, user_id, login_time, ip_address, user_agent, success FROM login_history
WHERE user_id = $1
ORDER BY login_time DESC
LIMIT $2
`

type GetUserLoginHistoryParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) GetUserLoginHistory(ctx context.Context, arg GetUserLoginHistoryParams) ([]LoginHistory, error) {
	rows, err := q.db.QueryContext(ctx, getUserLoginHistory, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginHistory{}
	for rows.Next() {
		var i LoginHistory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.LoginTime,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPermissions = `-- name: GetUserPermissions :many
SELECT p.code
FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
JOIN roles r ON rp.role_id = r.id
JOIN users u ON u.role_id = r.id
WHERE u.id = $1
`

func (q *Queries) GetUserPermissions(ctx context.Context, id int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUserPermissions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var code string
		if err := rows.Scan(&code); err != nil {
			return nil, err
		}
		items = append(items, code)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
SELECT id, name, description FROM roles ORDER BY name
`

func (q *Queries) ListRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, listRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT u.id, u.first_name, u.last_name, u.email, u.password_hash, u.nin, u.gender, u.date_of_birth, u.role_id, u.is_active, u.created_at, u.updated_at, r.name as role_name FROM users u
JOIN roles r ON u.role_id = r.id
ORDER BY u.created_at DESC
`

type ListUsersRow struct {
	ID           int32        `json:"id"`
	FirstName    string       `json:"first_name"`
	LastName     string       `json:"last_name"`
	Email        string       `json:"email"`
	PasswordHash string       `json:"password_hash"`
	Nin          string       `json:"nin"`
	Gender       string       `json:"gender"`
	DateOfBirth  time.Time    `json:"date_of_birth"`
	RoleID       int32        `json:"role_id"`
	IsActive     bool         `json:"is_active"`
	CreatedAt    sql.NullTime `json:"created_at"`
	UpdatedAt    sql.NullTime `json:"updated_at"`
	RoleName     string       `json:"role_name"`
}

func (q *Queries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.PasswordHash,
			&i.Nin,
			&i.Gender,
			&i.DateOfBirth,
			&i.RoleID,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logLoginAttempt = `-- name: LogLoginAttempt :one
INSERT INTO login_history (user_id, ip_address, user_agent, success)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, login_time, ip_address, user_agent, success
`

type LogLoginAttemptParams struct {
	UserID    int32          `json:"user_id"`
	IpAddress sql.NullString `json:"ip_address"`
	UserAgent sql.NullString `json:"user_agent"`
	Success   bool           `json:"success"`
}

func (q *Queries) LogLoginAttempt(ctx context.Context, arg LogLoginAttemptParams) (LoginHistory, error) {
	row := q.db.QueryRowContext(ctx, logLoginAttempt,
		arg.UserID,
		arg.IpAddress,
		arg.UserAgent,
		arg.Success,
	)
	var i LoginHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LoginTime,
		&i.IpAddress,
		&i.UserAgent,
		&i.Success,
	)
	return i, err
}

const logUserActivity = `-- name: LogUserActivity :one
INSERT INTO user_activity_logs (user_id, action, description, ip_address, user_agent)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, action, description, ip_address, user_agent, created_at
`

type LogUserActivityParams struct {
	UserID      int32          `json:"user_id"`
	Action      string         `json:"action"`
	Description string         `json:"description"`
	IpAddress   sql.NullString `json:"ip_address"`
	UserAgent   sql.NullString `json:"user_agent"`
}

func (q *Queries) LogUserActivity(ctx context.Context, arg LogUserActivityParams) (UserActivityLog, error) {
	row := q.db.QueryRowContext(ctx, logUserActivity,
		arg.UserID,
		arg.Action,
		arg.Description,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i UserActivityLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.Description,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const markTokenAsUsed = `-- name: MarkTokenAsUsed :exec
UPDATE password_reset_tokens
SET used = TRUE
WHERE id = $1
`

func (q *Queries) MarkTokenAsUsed(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markTokenAsUsed, id)
	return err
}

const removePermissionFromRole = `-- name: RemovePermissionFromRole :exec
DELETE FROM role_permissions
WHERE role_id = $1 AND permission_id = $2
`

type RemovePermissionFromRoleParams struct {
	RoleID       int32 `json:"role_id"`
	PermissionID int32 `json:"permission_id"`
}

func (q *Queries) RemovePermissionFromRole(ctx context.Context, arg RemovePermissionFromRoleParams) error {
	_, err := q.db.ExecContext(ctx, removePermissionFromRole, arg.RoleID, arg.PermissionID)
	return err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles
SET
    name = COALESCE($2, name),
    description = COALESCE($3, description)
WHERE id = $1
RETURNING id, name, description
`

type UpdateRoleParams struct {
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, updateRole, arg.ID, arg.Name, arg.Description)
	var i Role
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
    first_name = COALESCE($2, first_name),
    last_name = COALESCE($3, last_name),
    email = COALESCE($4, email),
    role_id = COALESCE($5, role_id),
    is_active = COALESCE($6, is_active),
    nin = COALESCE($7, nin),
    gender = COALESCE($8, gender),
    date_of_birth = COALESCE($9, date_of_birth),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, first_name, last_name, email, password_hash, nin, gender, date_of_birth, role_id, is_active, created_at, updated_at
`

type UpdateUserParams struct {
	ID          int32     `json:"id"`
	FirstName   string    `json:"first_name"`
	LastName    string    `json:"last_name"`
	Email       string    `json:"email"`
	RoleID      int32     `json:"role_id"`
	IsActive    bool      `json:"is_active"`
	Nin         string    `json:"nin"`
	Gender      string    `json:"gender"`
	DateOfBirth time.Time `json:"date_of_birth"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.RoleID,
		arg.IsActive,
		arg.Nin,
		arg.Gender,
		arg.DateOfBirth,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PasswordHash,
		&i.Nin,
		&i.Gender,
		&i.DateOfBirth,
		&i.RoleID,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID           int32  `json:"id"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}
